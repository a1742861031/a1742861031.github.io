

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yanbo">
  <meta name="keywords" content="">
  <title>前端常见面试题总结(持续更新) - bobooo blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="前端常见面试题总结(持续更新)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-02 15:21" pubdate>
        2021年3月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.7k ��
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      121
       ����
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端常见面试题总结(持续更新)</h1>
            
            <div class="markdown-body">
              <h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="doctype的作用？"><a href="#doctype的作用？" class="headerlink" title="doctype的作用？"></a>doctype的作用？</h3><p>DOCTYPE是html5标准网页声明，且必须声明在HTML文档的第一行。用来告知浏览器用什么文档标准解析这个文档。</p>
<p>文档解析类型</p>
<ul>
<li>BackCompat：怪异模式，当没有声明DOCTYPE时就是这一模式</li>
<li>CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面</li>
</ul>
<blockquote>
<p>IE8有一种近乎标准模式，基本被淘汰了</p>
</blockquote>
<p> 三种模式的区别</p>
<ul>
<li>标准模式：页面按照HTML与CSS的定义渲染</li>
<li>怪异模式：会模拟更旧的浏览器行为</li>
</ul>
<h3 id="对HTML语义化的理解？"><a href="#对HTML语义化的理解？" class="headerlink" title="对HTML语义化的理解？"></a>对HTML语义化的理解？</h3><p>元素本身传达了关于标签所包含内容类型的一些信息。看到该标签就知道是什么意思,例如<code>&lt;p&gt;</code>标签就代表段落，<code>&lt;article&gt;</code>代表正文等</p>
<p>HTML5提供了新的语义元素来定义网页的不同部分例如<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>、<code>aside</code>、<code>&lt;footer&gt;</code></p>
<h3 id="HTML5的特性"><a href="#HTML5的特性" class="headerlink" title="HTML5的特性"></a>HTML5的特性</h3><ul>
<li>文档类型声明为<code>&lt;!DOCTYPE HTML&gt;</code></li>
<li>标签语义化</li>
<li>支持对音视频的处理，不再使用flash</li>
<li>canvas/webGL画图</li>
<li>webSocket通信</li>
<li>history API</li>
<li>地理位置</li>
</ul>
<h3 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h3><ul>
<li>href：超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。</li>
</ul>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;common.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如上面所显示的，当浏览器加载到link标签时，会识别这是css文档，并行下载该CSS文档，但不会停止对当前页面后续内容的记载</p>
<ul>
<li>src表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。由浏览器在解析src时会停下对后续文档的处理，知道src内容加载完毕,常用在script、img、iframe标签中，建议js文件放在HTML文档的最后面。</li>
</ul>
<p>总结：href用于建立页面与引用资源之间的关系，而src会替换当前标签。遇到href,页面会并行加载后续内容;而遇到src浏览器会加载src中内容完毕后才继续往下</p>
<h3 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a>script标签中defer和async的区别</h3><ul>
<li>defer：浏览器指示脚本在文档被解析后执行，script被异步记载后并不会立即执行，而是等待文档被解析完毕后执行</li>
<li>async：同样是异步加载脚本，区别是脚本加载完毕后立即执行</li>
</ul>
<p>上图绿色线代表HTML解析，蓝色线代表<code>&lt;script&gt;</code>加载，而红色线代表<code>&lt;script&gt;</code>执行</p>
<p>由上图可见<code>&lt;script&gt;</code>标签默认是同步加载的，而defer和async是异步加载，而defer是文档加载完毕后script执行，async是·<code>&lt;script&gt;</code>加载完毕后立即执行</p>
<h3 id="前端存储方式"><a href="#前端存储方式" class="headerlink" title="前端存储方式"></a>前端存储方式</h3><p>主要是loaclStorage,cookies,sessionStorage、web SQL、indexedDB</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie是HTML5前的本地存储方式，兼容性好</p>
<blockquote>
<p>特点：</p>
<p>1、在请求服务器时，浏览器将cookie信息放在请求头中</p>
<p>2、在响应时，浏览器保存响应头中的Cookie信息</p>
<p>3、存储大小只有4kb</p>
<p>4、存储数量有限，一个domain最多20条</p>
<p>5、不安全，因为在请求头响应头中携带cookie信息</p>
</blockquote>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><blockquote>
<p>特点：</p>
<p>1、声明周期为永久性的，关闭浏览器也不会销毁，除非主动销毁</p>
<p>2、存储大小更大，一般为5M</p>
<p>3、以键值对方式存储</p>
<p>4、只能在同源下访问</p>
</blockquote>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>使用方式和localStorage大致相同</p>
<blockquote>
<p>特点:</p>
<p>这里主要说下和localStorage的不同</p>
<p>1、只能在同一窗口访问</p>
<p>2、关闭浏览器自动销毁</p>
</blockquote>
<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><h4 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h4><p>box-sizing:content-box</p>
<p><img src="https://ae01.alicdn.com/kf/U83afe781c7e748cc8b664200e99fe14aC.jpg" srcset="/img/loading.gif"></p>
<p>从上图可以看到标准 <strong><em>*</em>*W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。*\</strong>***</p>
<p>即指定元素的宽和高并不包括border和padding</p>
<blockquote>
<p>元素所占据的宽度 = margin-left+border-left+padding-left+width+padding-right+border-right+margin-right</p>
</blockquote>
<h4 id="怪异盒子模型-IE盒子模型"><a href="#怪异盒子模型-IE盒子模型" class="headerlink" title="怪异盒子模型(IE盒子模型)"></a>怪异盒子模型(IE盒子模型)</h4><p>box:sizing:border-box</p>
<p><img src="https://ae01.alicdn.com/kf/U8055704f951c49b09810817feac6de59d.jpg" srcset="/img/loading.gif"></p>
<p>　<strong>从上图可以看到 IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。</strong></p>
<p>这里指定元素的宽和高则包括border的padding</p>
<blockquote>
<p>元素所占据的宽度  =margin-left+width+margin-right</p>
</blockquote>
<h3 id="CSS选择器及其优先级"><a href="#CSS选择器及其优先级" class="headerlink" title="CSS选择器及其优先级"></a>CSS选择器及其优先级</h3><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><p>详情看博客  <a target="_blank" rel="noopener" href="https://blog.csdn.net/DYD850804/article/details/80997251?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=cda5ce45-09c2-4559-8cde-80544da3956d&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">https://blog.csdn.net/DYD850804/article/details/80997251?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=cda5ce45-09c2-4559-8cde-80544da3956d&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</a> 大佬写得真的好</p>
<ul>
<li><p>标签选择器，例如 p body h1等</p>
<p>选择的是页面上所有这种类型的标签，经常描述的是“共性”</p>
<p>例如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">14px</span><br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>ID选择器#</p>
<p>针对某一个特定的标签来使用，只能使用一次。css中的ID选择器以”#”来定义。</p>
</li>
<li><p>类选择器.</p>
<p>类选择器可以被多个标签使用，同一个标签可以使用多个类选择器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;classone  classtwo&quot;</span>&gt;</span>我是一个h3啊<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li><p>通配符*</p>
</li>
</ul>
<p>通配符即匹配任何标签例如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">*<span class="hljs-comment">/*定义通用选择器*，希望所有标签的上边距和左边距都为0*/</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>:<span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">0px</span>;<br><br></code></pre></td></tr></table></figure>
<p>一帮情况下，尽量使用class,id js用。类上样式，id上行为</p>
<h4 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h4><ul>
<li><p>后代选择器 空格隔开</p>
<p>这里强调一下：这两个标签不一定是连续紧挨着的，只要保持一个后代的关联即可。也就是说，选择的是后代，不一定是儿子。</p>
</li>
<li><p>交集选择器 .隔开</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span><span class="hljs-selector-class">.special</span>&#123; <span class="hljs-comment">/*注意这里没有空格*/</span><br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>选择的元素要求同时满足两个条件：必须是h3标签，然后必须是special标签。</p>
</li>
<li><p>并集选择器 逗号隔开</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-id">#mytitle</span>,<span class="hljs-selector-class">.one</span><span class="hljs-comment">/*定义了一个并集选择器，带有p,h1,id=&quot;mytitle&quot;,class=&quot;one&quot;的标签都内容会显示红色*/</span><br>&#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>伪类选择器</li>
</ul>
<p>对于<code>&lt;a&gt;</code>标签，其对应几种不同的状态：</p>
<ul>
<li><code>link</code>：超链接点击之前</li>
<li><code>visited</code>：超链接点击之后</li>
<li><code>focus</code>：是某个标签获得焦点的时候（比如某个输入框获得焦点）</li>
<li><code>hover</code>：鼠标放到某个标签上的时候</li>
<li><code>active</code>：点击某个标签没有松鼠标时</li>
</ul>
<p>CSS允许对于元素的不同状态，定义不同的样式信息。伪类选择器又分为两种：</p>
<ul>
<li>静态伪类：只能用于超链接</li>
<li>动态伪类：针对所有标签都适用</li>
</ul>
<p>下面来分别讲一下这两种伪类选择器。</p>
<p><strong>静态伪类：</strong></p>
<p>用于以下两个状态（*<strong>*只能使用于超链接**</strong>）：</p>
<ul>
<li><code>link</code>：超链接点击之前</li>
<li><code>visited</code>：超链接点击之后</li>
</ul>
<p><strong>（2）动态伪类:</strong></p>
<p>用于以下几种状态（适用于所有的标签）：</p>
<ul>
<li><code>focus（聚焦，点击某个文本框后输入文字，可以定义文本框和文字的属性）</code>：是某个标签获得焦点的时候（比如某个输入框获得焦点）</li>
<li><code>hover（盘旋，鼠标停留在上面）</code>：鼠标放到某个标签上的时候</li>
<li><code>active（长按状态）</code>：点击某个标签没有松鼠标时</li>
</ul>
<p>举个例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style type=&quot;text/css&quot;&gt;<br>        <span class="hljs-comment">/* 伪类选择器：动态伪类*/</span><br>        <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span><br><br>        <span class="hljs-comment">/*让input文本框获取焦点时：边框：#FF6F3D这种橙色；文字：绿色；背景色：#6a6a6a这种灰色*/</span><br>            &#123;<br>            <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#FF6F3D</span>;<br>            <span class="hljs-attribute">color</span>: white;<br>            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#6a6a6a</span>;<br>        &#125;<br><br>        <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:hover</span><br><br>        <span class="hljs-comment">/*鼠标放在label标签上时显示蓝色*/</span><br>            &#123;<br>            <span class="hljs-attribute">color</span>: blue;<br>        &#125;<br><br>        <span class="hljs-selector-tag">label</span><span class="hljs-selector-pseudo">:active</span><br><br>        <span class="hljs-comment">/*点击label标签鼠标没有松开时显示红色*/</span><br>            &#123;<br>            <span class="hljs-attribute">color</span>: red;<br>        &#125;<br>    &lt;/<span class="hljs-selector-tag">style</span>&gt;<br></code></pre></td></tr></table></figure>
<h4 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">p</span>&#123;<br>	<span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>div的儿子p。和div的后代p的截然不同。</p>
<h4 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>+<span class="hljs-selector-tag">p</span>&#123;<br>	<span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上方的选择器意思是：选择的是h3元素后面紧挨着的第一个兄弟。</p>
<h4 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first-child</span>&#123;<br>		<span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-comment">/*设置无序列表&lt;ul&gt;中的最后一个&lt;li&gt;为红色：*/</span><br></code></pre></td></tr></table></figure>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>!important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认</p>
<ul>
<li>内联样式表的权值为 1000</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ul>
<p>例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">        <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.test</span>&#123;</span><br><span class="css">            <span class="hljs-selector-tag">background-COLOR</span>:<span class="hljs-selector-id">#a00</span>;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br>            height: 100px;<br>        &#125;<br><br><span class="css">        <span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.test2</span>&#123;</span><br><span class="css">            <span class="hljs-selector-tag">background-COLOR</span>:<span class="hljs-selector-id">#0e0</span>;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br>            height: 100px;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test test2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p> 我们可以把选择器中规则对应做加法，比较权值，如果权值相同那就后面的覆盖前面的了，div.class的权值是1+10=11，而.test1 .test2的权值是10+10=20，所以div会应用.test1 .test2变成绿色</p>
<p>　①、!important的优先级是最高的，但出现冲突时则需比较”四位数“;</p>
<p>　②、优先级相同时，则采用就近原则，选择最后出现的样式;</p>
<p>　③、继承得来的属性，其优先级最低;</p>
<p>原博客链接 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zxjwlh/p/6213239.html">https://www.cnblogs.com/zxjwlh/p/6213239.html</a></p>
<h3 id="水平垂直居中的集中实现方式"><a href="#水平垂直居中的集中实现方式" class="headerlink" title="水平垂直居中的集中实现方式"></a>水平垂直居中的集中实现方式</h3><ul>
<li>三种定位</li>
</ul>
<ul>
<li><p>绝对定位+margin负边距</p>
<p>必须要知道具体的宽和高</p>
<p><img src="https://img-blog.csdnimg.cn/2019100300223157.png" srcset="/img/loading.gif" alt="图示"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">给元素设置定位<span class="hljs-selector-tag">absolute</span>，父元素设置定位<span class="hljs-selector-tag">absolute</span>或<span class="hljs-selector-tag">relative</span>，参考绝对定位原理，绝对定位是相对最近一个设置定位属性(非<span class="hljs-selector-tag">static</span>)的父级元素的，给元素设置<span class="hljs-selector-tag">left</span>: 50%, <span class="hljs-selector-tag">right</span>: 50% 后，元素现在的位置如上图所示，现在元素的位置稍微偏离正中心，容易发现距离上边界、左边界是元素自身高度的一半，使用负边界可以使元素往左上角移动。<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>绝对定位+margin:auto</p>
<p>这种方案元素必须要有宽和高</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>- 绝对定位 + transform

  存在兼容性问题，但是不需要给元素指定宽和高

  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">.box &#123;<br>  position: relative;<br>&#125;<br>.item &#123;<br>  position: absolute;<br>  left: <span class="hljs-number">50</span>%;<br>  top: <span class="hljs-number">50</span>%;<br>  transform: translate(-<span class="hljs-number">50</span>%, -<span class="hljs-number">50</span>%);<br>&#125;<br><br></code></pre></td></tr></table></figure>


  对于行内元素，通过给父级元素设定text-align属性为center。</code></pre>
<ul>
<li><p>display:flex</p>
<p>让其父容器实现flex布局</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex; <br>    <span class="hljs-attribute">justify-content</span>:center; <br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>JavaScript</p>
<p>1）获取到当前屏幕的高度；</p>
<p>2）获取到需要居中的div的高度；</p>
<p>3）用屏幕的高度减去div的高度除以2就是需要给div设计的margin-top/padding-top的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;box&quot;</span>id=<span class="hljs-string">&quot;box&quot;</span>&gt;&lt;div&gt;<br><span class="hljs-keyword">let</span> HTML = <span class="hljs-built_in">document</span>.documentElement,<br>    winW = HTML.clientWidth,<br>    winH = HTML.clientHeight,<br>    boxW = box.offsetWidth,<br>    boxH = box.offsetHeight<br>box.style.position = <span class="hljs-string">&quot;absolute&quot;</span>;<br>box.style.left = (winW-boxW)/<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;px&#x27;</span>;<br>box.style.top = (winH-boxH)/<span class="hljs-number">2</span> + <span class="hljs-string">&#x27;px&#x27;</span><br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="相对定位与绝对定位"><a href="#相对定位与绝对定位" class="headerlink" title="相对定位与绝对定位"></a>相对定位与绝对定位</h3><p><strong>relative</strong>：定位是相对于自身位置定位（设置偏移量的时候，会相对于自身所在的位置偏移）。设置了 relative 的元素仍然处在文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置。最外层容器设置为 relative 定位，在没有设置宽度的情况下，宽度是整个浏览器的宽度。</p>
<p><strong>absolute</strong>：定位是相对于离元素最近的设置了绝对或相对定位的父元素决定的，如果没有父元素设置绝对或相对定位，则元素相对于根元素即 html 元素定位。设置了 absolute 的元素脱了了文档流，元素在没有设置宽度的情况下，宽度由元素里面的内容决定。脱离后原来的位置相当于是空的，下面的元素会来占据位置。</p>
<p>总结：即相对定位是相对于自身的位置进行定位，而绝对定位是相对于最近的设置了绝对或相对定位的父级元素进行定位</p>
<p>补充</p>
<blockquote>
<p>static: 正常⽂档流定位，此时 top, right, bottom, left 和 z-index 属性⽆效，块级元素从上往下纵向排布，⾏级元素<br>从左向右排列。</p>
</blockquote>
<h3 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h3><ul>
<li><p><code>opacity：0</code> 将元素的透明度设为0，就看起来隐藏了，但可以进行交互</p>
</li>
<li><p><code>visibility:false</code> 依然占据空间，但不能进行数据交互</p>
</li>
<li><p><code>overflow:hidden</code>:只隐藏元素的溢出部分</p>
<p>补充：overflow:hidden的几个作用</p>
<blockquote>
<p>1、溢出隐藏</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123; <br> <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br> <span class="hljs-attribute">background</span>: skyblue;<br> <span class="hljs-attribute">overflow</span>: hidden;      <span class="hljs-comment">/*溢出隐藏*/</span><br> <span class="hljs-attribute">white-space</span>: nowrap;	<span class="hljs-comment">/*规定文本不进行换行*/</span><br> <span class="hljs-attribute">text-overflow</span>: ellipsis;	<span class="hljs-comment">/*当对象内文本溢出时显示省略标记（...）*/</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
</blockquote>
<blockquote>
<p>2、清除浮动</p>
<p>，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。那么问题来了，如下：</p>
</blockquote>
<blockquote>
<p>如上，由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。因此，需要给父级加个overflow:hidden属性，这样父级的高度就随子级容器及子级内容的高度而自适应。如下：</p>
</blockquote>
<blockquote>
<p>3、解决外边距塌陷</p>
<p>父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷，如下：</p>
</blockquote>
<blockquote>
<p>因此，给父级元素添加overflow:hidden，就可以解决这个问题了。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>display:none：这个是彻底隐藏了元素，元素从文档流中消失，同时不占据空间</p>
</li>
<li><p>z-index:-9999 : 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</p>
</li>
</ul>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><h4 id="块状元素"><a href="#块状元素" class="headerlink" title="块状元素"></a>块状元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>...<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>总是从新行开始</li>
<li>高度、行高、外边距以及内边距可以控制</li>
<li>宽度默认是容器的100%</li>
<li>可以容纳行内（内联）元素和其他块元素</li>
</ul>
<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span> 链接<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>把文本定义为强调的内容<br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>吧文本定义为语气更强的强调内容<br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>引用<br><span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>计算机文本代码<br></code></pre></td></tr></table></figure>
<ul>
<li>和相邻内元素在一行上</li>
<li>不能设置高度和宽度，但在水平方向可以设置padding和margin，垂直方向无法设置</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或者其他行内元素，a特殊</li>
</ul>
<h4 id="行内块状"><a href="#行内块状" class="headerlink" title="行内块状"></a>行内块状</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;img&gt;</span><br><span class="hljs-section">&lt;input&gt;</span><br><span class="hljs-section">&lt;td&gt;</span><br></code></pre></td></tr></table></figure>
<p>特点</p>
<ul>
<li>和相邻行内元素(行内块)在同一行上，但是之间会有空白缝隙</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>高度、行高、外边距、内边距可以控制</li>
</ul>
<h4 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h4><ul>
<li>一个块级元素独占一行，而行内元素与其他行内元素并排</li>
<li>块级元素可以设置宽度和高度，而行内元素不可以</li>
<li>块级元素的长度和宽度默认是父级容器的100%，而行内元素的宽度是内容的宽度</li>
</ul>
<h4 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">dispaly</span><span class="hljs-selector-pseudo">:inline</span>; <span class="hljs-comment">/*转换成行内元素*/</span><br><span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:block</span>; <span class="hljs-comment">/*转换成块级元素*/</span><br><span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:inline-block</span>;<span class="hljs-comment">/*转换成行内块状元素*/</span><br></code></pre></td></tr></table></figure>


<h4 id="display出了这几个值还有哪些"><a href="#display出了这几个值还有哪些" class="headerlink" title="display出了这几个值还有哪些"></a>display出了这几个值还有哪些</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:none</span>;<br><span class="hljs-selector-tag">display</span><span class="hljs-selector-pseudo">:flex</span>;<span class="hljs-comment">/*响应式布局*/</span><br></code></pre></td></tr></table></figure>
<h4 id="试说明z-index的工作原理"><a href="#试说明z-index的工作原理" class="headerlink" title="试说明z-index的工作原理"></a>试说明z-index的工作原理</h4><ul>
<li><p>文档流</p>
<p>值越大表明距离用户越近</p>
<p><img src="https://ae01.alicdn.com/kf/U83afe781c7e748cc8b664200e99fe14aC.jpg" srcset="/img/loading.gif"></p>
</li>
<li><p>定位</p>
<p>z-index只对定位元素有作用</p>
<p><img src="https://ae01.alicdn.com/kf/U8055704f951c49b09810817feac6de59d.jpg" srcset="/img/loading.gif"></p>
</li>
</ul>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul>
<li>空div⽅法： <code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></li>
<li>Clearfix ⽅法：上⽂使⽤.clearfix类已经提到</li>
<li>overflow: auto或overflow: hidden⽅法，使⽤BFC</li>
</ul>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><h3 id="em-px-rem区别"><a href="#em-px-rem区别" class="headerlink" title="em/px/rem区别"></a>em/px/rem区别</h3><ul>
<li>px：绝对当为，页面按照像素进行展示</li>
<li>em：相对单位 基准点为父节点字体的大小</li>
<li>rem：相对当为 基准点为根节点html字体的大小</li>
</ul>
<h3 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h3><ul>
<li>link属于XHTML标签，而@import是CSS提供的</li>
<li>页面被加载时，link会同时被加载，而@import应用的CSS会等到页面被加载完毕再加载</li>
<li>link的权重高于@import</li>
<li>link标签的样式可以DOM操作改变 而@import不可以</li>
</ul>
<h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><h3 id="JS的变量提升"><a href="#JS的变量提升" class="headerlink" title="JS的变量提升"></a>JS的变量提升</h3><p>js运行时先解析代码，获取所有被声明的变量，然后再一行一行运行。将所有变量的声明语句提升到代码的头部。（var变量）或函数声明(function(){ })</p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>b(); <span class="hljs-comment">//1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将变量的声明提到最前面，所以执行顺序应该是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><span class="hljs-built_in">console</span>.log(a);<br>a = <span class="hljs-number">1</span>;<br>b();<br></code></pre></td></tr></table></figure>
<p>当一个变量声明但没有赋值，这个变量就是undefined，如果一个变量没有声明，则会报错</p>
<blockquote>
<p>注意：let 和const没有变量提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-number">123</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;456&#x27;</span>)<br>&#125;<br>fn();<br><span class="hljs-comment">//执行顺序为</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;456&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> fn;<br>fn = <span class="hljs-number">123</span>;<br>fn();<span class="hljs-comment">//报错 fn is not a function</span><br></code></pre></td></tr></table></figure>

<p>预解析时先解析函数fn，然后再解析变量fn，后面的变量fn会把前面的函数fn覆盖，所以最后执行fn()会报错</p>
</blockquote>
<h3 id="JS-执行机制"><a href="#JS-执行机制" class="headerlink" title="JS 执行机制"></a>JS 执行机制</h3><p>JS是单线程语言</p>
<p>JS的执行机制为Event Loop(事件循环)</p>
<p>JS的任务分为同步任务和异步任务，其中在主线程执行的任务为同步任务，被主线程挂载的任务为异步任务，后者一般放在一个任务队列中(Event Quene)，</p>
<p>且不同类型的异步任务（分为宏任务和微任务)</p>
<p>JS异步执行方式为</p>
<ul>
<li>所有的同步任务都在主线程执行，形成一个执行栈</li>
<li>主线程之外，还有一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件</li>
<li>不同任务执行完毕后，系统会读取“任务队列”，看看里面有哪些事件。进入执行栈，开始执行异步任务</li>
<li>主线程不断重复上面的三步</li>
</ul>
<p>宏任务：整体代码script，setTimeOut 、setInterval</p>
<blockquote>
<p>setTimeOut和setInterval的区别</p>
<p>setTimeOut只执行一个，而setInterval为设置没间隔多久执行一次</p>
</blockquote>
<p>微任务：promise.then,process.nextTick(node)</p>
<p><img src="https://img-blog.csdnimg.cn/20190727201859866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pENzE3ODIyMDIz,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer1</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br>add();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer2</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer3</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<br>  &#125;, <span class="hljs-number">100</span>)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    i == <span class="hljs-number">99</span> &amp;&amp; resolve()<br>  &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// timer4</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>) <br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>)<br><span class="hljs-comment">//最后的执行结果为 1 4 8 7 3 6 5 2</span><br></code></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包：一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包，</p>
<p>利用闭包实现变量的私有化</p>
<p>为什么会形成闭包：程序在访问变量时，是向底层栈一个一个找，如果找到全局执行环境里都没有对应变量，则程序抛出undefined错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(b);<br>    &#125;<br>    fn1();<br>&#125;<br>fn();<br></code></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-keyword">var</span> name =<span class="hljs-string">&#x27;bobo&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.setName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>        name = value;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> bobo = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(bobo.getName()); <span class="hljs-comment">//bobo</span><br>bobo.setName(<span class="hljs-string">&#x27;Yanbo&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(bobo.getName());<span class="hljs-comment">//Yanbo</span><br><span class="hljs-built_in">console</span>.log(name)<span class="hljs-comment">//name is undefinded</span><br></code></pre></td></tr></table></figure>
<p>JS闭包中的坑：</p>
<p>1、引用的变量可能发生变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> result = [];<br>      <span class="hljs-keyword">for</span> （<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>； i&lt;<span class="hljs-number">10</span>; i++）&#123;<br>        result.[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.info(i)<br>        &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-comment">//最后打印的结果并不是 1 2 3 ...10 而是10 10 10 ...10</span><br><span class="hljs-comment">//因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， ..., 10</span><br></code></pre></td></tr></table></figure>
<p>解决方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> result = [];<br>      <span class="hljs-keyword">for</span> （<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>； i&lt;<span class="hljs-number">10</span>; i++）&#123;<br>        result.[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                   <span class="hljs-built_in">console</span>.info(num);    <span class="hljs-comment">// 此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样</span><br>             &#125;<br>        &#125;(i)<br>     &#125;<br>     <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2、this的指向问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> object = &#123;<br>     name: <span class="hljs-string">&#x27;&#x27;</span>object<span class="hljs-string">&quot;，</span><br><span class="hljs-string">     getName： function() &#123;</span><br><span class="hljs-string">        return function() &#123;</span><br><span class="hljs-string">             console.info(this.name)</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">object.getName()()    // underfined</span><br><span class="hljs-string">// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span><br></code></pre></td></tr></table></figure>
<p>3、内存泄漏问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">showId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>)<br>    el.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>      aler(el.id)   <span class="hljs-comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span><br>    &#125;<br>&#125;<br>j<br><span class="hljs-comment">// 改成下面</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">showId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>)<br>    <span class="hljs-keyword">var</span> id  = el.id<br>    el.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>      alert(id)   <span class="hljs-comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span><br>    &#125;<br>    el = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 主动释放el</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h3><h4 id="构造函数与普通函数的区别"><a href="#构造函数与普通函数的区别" class="headerlink" title="构造函数与普通函数的区别"></a>构造函数与普通函数的区别</h4><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 <code>new</code> 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的 <code>Person()</code> 函数可以通过下列任何一种方式来调用</p>
<p>通过构造函数创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.name = <span class="hljs-string">&quot;kevin&quot;</span>;<br><span class="hljs-built_in">console</span>.log(person.name);<span class="hljs-comment">//kevin</span><br></code></pre></td></tr></table></figure>
<p>这里的Person()就是一个构造函数，通过new创建了一个实例对象</p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>每个函数都有一个prototype属性</p>
<p>每一个JS属性都会在创建时关联另外一个对象，每一个对象都会从原型上继承属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <br>&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;bobo&#x27;</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(person.name);<span class="hljs-comment">//bobo</span><br></code></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Ud6ca447ab0ad424fb51093b040b532ccs.jpg" srcset="/img/loading.gif"></p>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h4><p>每个对象都有一个proto属性，指向对象的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>


<h4 id="contructor"><a href="#contructor" class="headerlink" title="contructor"></a>contructor</h4><p>每一个原型都有一个constructor属性指向关联的构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(Person === Person.prototype.constructor) <span class="hljs-comment">//true</span><br><span class="hljs-comment">//顺便学习一个ES5获取对象原型的方法</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(person)===Person.prototype)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p><img src="https://ae01.alicdn.com/kf/U5fbc4c20bb1841638aeb74c96d568a38v.jpg" srcset="/img/loading.gif"></p>
<p><code>console.log(Object.prototype.__proto__ === null) // true</code></p>
<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> friend = <span class="hljs-keyword">new</span> Person();<br>Person.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;;<br>friend.sayHi();   <span class="hljs-comment">// &quot;hi&quot;（没有问题！）</span><br></code></pre></td></tr></table></figure>
<p>如果是重写整个原型对象，则会有问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> friend = <span class="hljs-keyword">new</span> Person();<br><br>Person.prototype = &#123;<br>    <span class="hljs-title">constructor</span>: <span class="hljs-title">Person</span>,<br>    <span class="hljs-title">name</span> : &quot;<span class="hljs-title">Stone</span>&quot;,<br>    <span class="hljs-title">age</span> : 28,<br>    <span class="hljs-title">job</span> : &quot;<span class="hljs-title">Software</span> <span class="hljs-title">Engineer</span>&quot;,<br>    <span class="hljs-title">sayName</span> : <span class="hljs-title">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;;<br><br>friend.sayName();   <span class="hljs-comment">// Uncaught TypeError: friend.sayName is not a function</span><br></code></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>Person.prototype = &#123;<br>    <span class="hljs-title">constructor</span>: <span class="hljs-title">Person</span>,<br>    <span class="hljs-title">name</span> : &quot;<span class="hljs-title">Stone</span>&quot;,<br>    <span class="hljs-title">age</span> : 28,<br>    <span class="hljs-title">job</span> : &quot;<span class="hljs-title">Software</span> <span class="hljs-title">Engineer</span>&quot;,<br>    <span class="hljs-title">friends</span> : [&quot;<span class="hljs-title">ZhangSan</span>&quot;, &quot;<span class="hljs-title">LiSi</span>&quot;],<br>    <span class="hljs-title">sayName</span> : <span class="hljs-title">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><br>person1.friends.push(<span class="hljs-string">&quot;WangWu&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(person1.friends);    <span class="hljs-comment">// &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="hljs-built_in">console</span>.log(person2.friends);    <span class="hljs-comment">// &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="hljs-built_in">console</span>.log(person1.friends === person2.friends);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>当在原型中添加引用类型值时，所有对象共享这个引用类型值</p>
<p>解决方法：构造函数与原型结合</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.job = job;<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&quot;ZhangSan&quot;</span>, <span class="hljs-string">&quot;LiSi&quot;</span>];<br>&#125;<br><br>Person.prototype = &#123;<br>    <span class="hljs-title">constructor</span> : <span class="hljs-title">Person</span>,<br>    <span class="hljs-title">sayName</span> : <span class="hljs-title">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Stone&quot;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Sophie&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;English Teacher&quot;</span>);<br><br>person1.friends.push(<span class="hljs-string">&quot;WangWu&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person1.friends);    <span class="hljs-comment">// &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="hljs-built_in">console</span>.log(person2.friends);    <span class="hljs-comment">// &quot;ZhangSan,LiSi&quot;</span><br><span class="hljs-built_in">console</span>.log(person1.friends === person2.friends);    <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(person1.sayName === person2.sayName);    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><p>基本数据类型，<code>Number</code>,<code>String</code>,<code>Boolean</code>,<code>undeined</code>,<code>null</code>,</p>
<p>引用数据类型：Object，包括(Function,Array,Date)</p>
<p>ES6新增的Symbol数据类型</p>
<p>NaN是Number中的特殊值</p>
<h4 id="null与undefined的区别"><a href="#null与undefined的区别" class="headerlink" title="null与undefined的区别"></a>null与undefined的区别</h4><p>null表示为空，代表此处不应该有值的存在，⼀个对象可以是null，代表是个空对象，⽽null本身也是对象</p>
<p>undefined表示没有定义，在使用var 声明变量但未对其加初始化时，这个变量就是undefined。</p>
<h3 id="JS-call-和apply"><a href="#JS-call-和apply" class="headerlink" title="JS call()和apply()"></a>JS call()和apply()</h3><p><code>call()</code>和<code>apply()</code>用来重新定义函数的执行环境，也就是改变this指向，</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>用一个给定的this值和单独给出的一个或多个参数来调用一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Product</span>(<span class="hljs-params">name, price</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.price = price;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Food</span>(<span class="hljs-params">name, price</span>) </span>&#123;<br>  Product.call(<span class="hljs-built_in">this</span>, name, price);<br>  <span class="hljs-built_in">this</span>.category = <span class="hljs-string">&#x27;food&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Food(<span class="hljs-string">&#x27;cheese&#x27;</span>, <span class="hljs-number">5</span>).name);<br><span class="hljs-comment">// expected output: &quot;cheese&quot;</span><br><br></code></pre></td></tr></table></figure>
<p>这里Product函数本来是在全局作用域下的，在全局作用域下指向应该指向window，我们通过call方法，让Product的this指向，在new 创建一个新的对象时，this会指向这个新的对象，</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>apply和call方法类似，call()函数接收的是参数列表，而aplly()接收的是一个参数数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];<br><br><span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, numbers);<br><br><span class="hljs-built_in">console</span>.log(max);<br><span class="hljs-comment">// expected output: 7</span><br><br><span class="hljs-keyword">const</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, numbers);<br><br><span class="hljs-built_in">console</span>.log(min);<br><span class="hljs-comment">// expected output: 2</span><br><br></code></pre></td></tr></table></figure>
<h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>this的指向在函数定义时不能确定，在函数执行时才能确定this的指向问题</p>
<ul>
<li><p>默认情况下，this指向window(默认绑定)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">name = <span class="hljs-string">&quot;Bale&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br>sayName(); <span class="hljs-comment">//&quot;Bale&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>隐式绑定</p>
<p>如果函数被调⽤的位置存在上下⽂对象时，那么函数是被隐式绑定的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">this</span>.name );<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>name: <span class="hljs-string">&quot;Messi&quot;</span>,<br>f: f<br>&#125;;<br>obj.f(); <span class="hljs-comment">//被调⽤的位置恰好被对象obj拥有，因此结果是Messi</span><br></code></pre></td></tr></table></figure>
<ul>
<li>显式绑定</li>
</ul>
<p>即通过call，apply，bind</p>
</li>
</ul>
<ul>
<li><p>new调用构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">console</span>.log(name);<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Messi&#x27;</span>); <span class="hljs-comment">//Messi</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="JS参数传递"><a href="#JS参数传递" class="headerlink" title="JS参数传递"></a>JS参数传递</h3><h4 id="基本数据类型按值传递"><a href="#基本数据类型按值传递" class="headerlink" title="基本数据类型按值传递"></a>基本数据类型按值传递</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x</span>) </span>&#123;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(x);<br>&#125;<br>test(a); <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<h4 id="复杂数据类型按引用传递"><a href="#复杂数据类型按引用传递" class="headerlink" title="复杂数据类型按引用传递"></a>复杂数据类型按引用传递</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<br>a: <span class="hljs-number">1</span>,<br>b: <span class="hljs-number">2</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x</span>) </span>&#123;<br>x.a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(x);<br>&#125;<br>test(a); <span class="hljs-comment">// &#123; a: 10, b: 2 &#125;</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// &#123; a: 10, b: 2 &#125;</span><br></code></pre></td></tr></table></figure>
<p>函数的实参和形参公用一个堆内存</p>
<p>如何解决？</p>
<p>先将该引用类型值深克隆一份</p>
<h3 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h3><p>async/await是基于promise实现的，就是通过看起来是同步的方式实现异步的代码</p>
<p>async函数返回的时一个Promise对象，并且是隐式返回的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="hljs-comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeLongTime</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基于promise.then实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    step1(time1)<br>        .then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))<br>        .then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))<br>        .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><br>doIt();<br><br><span class="hljs-comment">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="hljs-comment">// step1 with 300</span><br><span class="hljs-comment">// step2 with 500</span><br><span class="hljs-comment">// step3 with 700</span><br><span class="hljs-comment">// result is 900</span><br><span class="hljs-comment">// doIt: 1507.251ms</span><br></code></pre></td></tr></table></figure>
<p>基于async、awaite实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> step1(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> step2(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> step3(time3);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><br>doIt();<br></code></pre></td></tr></table></figure>


<h3 id="解析字符串和字符串强制类型转换的区别"><a href="#解析字符串和字符串强制类型转换的区别" class="headerlink" title="解析字符串和字符串强制类型转换的区别"></a>解析字符串和字符串强制类型转换的区别</h3><h4 id="解析字符串parseInt-中含有非数字字符，解析按照从左到右的顺序，遇到非数字型字符串解析就会停止"><a href="#解析字符串parseInt-中含有非数字字符，解析按照从左到右的顺序，遇到非数字型字符串解析就会停止" class="headerlink" title="解析字符串parseInt()中含有非数字字符，解析按照从左到右的顺序，遇到非数字型字符串解析就会停止"></a>解析字符串parseInt()中含有非数字字符，解析按照从左到右的顺序，遇到非数字型字符串解析就会停止</h4><h4 id="字符串强制类型转换不允许出现非数字字符，否则会失败并返回NaN"><a href="#字符串强制类型转换不允许出现非数字字符，否则会失败并返回NaN" class="headerlink" title="字符串强制类型转换不允许出现非数字字符，否则会失败并返回NaN"></a>字符串强制类型转换不允许出现非数字字符，否则会失败并返回NaN</h4><h3 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h3><h4 id="直接通过Object创建"><a href="#直接通过Object创建" class="headerlink" title="直接通过Object创建"></a>直接通过Object创建</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>person.name = <span class="hljs-string">&#x27;bobo&#x27;</span>;<br>person.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<br>	name: <span class="hljs-string">&#x27;bobo&#x27;</span>;<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.sayName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span>(<span class="hljs-params">name,age,job</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    o.name = name;<br>    o.age = age;<br>    a.job.job;<br>    o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = createPerson(<span class="hljs-string">&#x27;bobo&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;student&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name,age,job</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.job = job;<br>    <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Robot</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;bobo&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;student&#x27;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;bo&#x27;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;gamer&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person1 <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(Person2 <span class="hljs-keyword">instanceof</span> Robot);<span class="hljs-comment">//false</span><br><span class="hljs-comment">//补充：构造函数与普通函数的区别：构造函数是用来创建新的对象(通过new关键字)，如果是像普通函数一样调用的话，它的作用就相当于普通函数</span><br><span class="hljs-comment">//例如：</span><br>Person(<span class="hljs-string">&#x27;zzx&#x27;</span>,<span class="hljs-number">20</span>,teacher);<br>sayName();<span class="hljs-comment">//&#x27;zzx&#x27;</span><br><span class="hljs-comment">//调用时，this指向window</span><br></code></pre></td></tr></table></figure>
<h4 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="headerlink" title="组合使用构造函数模式与原型模式"></a>组合使用构造函数模式与原型模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.job = job;<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;wc&#x27;</span>, <span class="hljs-string">&#x27;rt&#x27;</span>];<br>&#125;<br><br>Person.prototype = &#123;<br>    <span class="hljs-title">constructor</span>: <span class="hljs-title">Person</span>,<br>    <span class="hljs-title">sayName</span>: <span class="hljs-title">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//用原型定义共享的方法和属性，构造函数用于定义原型属性</span><br></code></pre></td></tr></table></figure>
<h4 id="寄生创建函数模式"><a href="#寄生创建函数模式" class="headerlink" title="寄生创建函数模式"></a>寄生创建函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>    o.name = name;<br>    o.age = age;<br>    o.job = job;<br>    o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;zzx&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;Programmer&#x27;</span>);<br>person1.sayName();<br><span class="hljs-comment">//封装创建对象的代码</span><br></code></pre></td></tr></table></figure>
<h3 id="JS实现继承的几种方法"><a href="#JS实现继承的几种方法" class="headerlink" title="JS实现继承的几种方法"></a>JS实现继承的几种方法</h3><p>定义父类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义一个动物类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Animal&#x27;</span>;<br>    <span class="hljs-comment">//实例方法</span><br>    <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉&#x27;</span>)<br>    &#125;	<br>&#125;<br><span class="hljs-comment">//原型方法</span><br>Animal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在吃&#x27;</span> + food);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Cat.prototype = <span class="hljs-keyword">new</span> Animal();<br>    Cat.prototype.name = <span class="hljs-string">&#x27;cat&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>致命缺点：来自原型对象的所有属性被所以实例共享；创造子类实例时，无法向父类构造函数传参</p>
<h4 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    Animal.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false 注意这</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// tru</span><br></code></pre></td></tr></table></figure>
<p>只能继承实例属性和方法，不能继承原型属性和方法</p>
<h4 id="3、实例继承"><a href="#3、实例继承" class="headerlink" title="3、实例继承"></a>3、实例继承</h4><p>缺点：只是父类的实例，不是子类的实例</p>
<h4 id="4、拷贝继承"><a href="#4、拷贝继承" class="headerlink" title="4、拷贝继承"></a>4、拷贝继承</h4><p>效率较低，内存占用高 不可枚举</p>
<h4 id="5、组合继承"><a href="#5、组合继承" class="headerlink" title="5、组合继承"></a>5、组合继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    Animal.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>Cat.prototype = <span class="hljs-keyword">new</span> Animal();<br>Cat.prototype.constructor = Cat;<span class="hljs-comment">//修改构造函数指向</span><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>既是子类的实例，也是父类的实例</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ol>
<p>缺点：</p>
<ol>
<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li>
</ol>
<h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><p>实现较复杂</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当访问一个变量时，编译器在执行这段代码时，会现在当前作用域查找，如果没有找到，则向父级作用域进行查找，知道全局作用域为止，而作用域链，就是当前当前作用域与上层作用域一系列变量对象的组成，保证当前执行的作用域对符合权限的变量、函数的有序访问。</p>
<h2 id="http部分"><a href="#http部分" class="headerlink" title="http部分"></a>http部分</h2><h3 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h3><ul>
<li>数据传输方式不同：GET通过URL传递数据，而Post的数据通过请求体传输数据，因此post的安全性更高    </li>
<li>GET只允许ASCII码，而POST无限制</li>
<li>GET只读，不会更改服务器的数据，</li>
<li>GET无害，POST可能会重复提交表单</li>
</ul>
<h3 id="post与put的区别"><a href="#post与put的区别" class="headerlink" title="post与put的区别"></a>post与put的区别</h3><p>PUT 和POST⽅法的区别是,PUT⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽POST⽅法是⾮幂等的</p>
<p>例如：使用post提交一篇博客可能重复提交多次，而put只会提交一次</p>
<h3 id="put和patch的区别"><a href="#put和patch的区别" class="headerlink" title="put和patch的区别"></a>put和patch的区别</h3><p>PUT和PATCH都是更新资源，⽽PATCH⽤来对已知资源进⾏局部更新。即更改部分数据</p>
<h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><ul>
<li>请求行</li>
<li>请求头部</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p><img src="https://img.imgdb.cn/item/603b06f55f4313ce25816428.jpg" srcset="/img/loading.gif"></p>
<p>请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。</p>
<p>请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔User-Agent：产⽣请求的浏览器类型。</p>
<p>Accept：客户端可识别的内容类型列表。</p>
<p>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</p>
<p>请求体: post put等请求携带的数据</p>
<h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><ul>
<li>响应行：由协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。</li>
<li>响应头：响应部⾸组成</li>
<li>空行</li>
<li>响应体：服务器响应的数据</li>
</ul>
<h3 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h3><ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>201 Created 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴</li>
<li>202 Accepted 请求已接受，但是还没执⾏，不保证完成请求</li>
<li>204 No content，表示请求成功，但响应报⽂不含实体的主体部分</li>
<li>206 Partial Content，进⾏范围请求</li>
</ul>
</li>
<li><h2 id="3xx：重定向–要完成请求必须进行更进一步的操作。"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作。" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作。"></a>3xx：重定向–要完成请求必须进行更进一步的操作。</h2></li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。<ul>
<li>400 bad request，请求报⽂存在语法错误 ✨</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
<li>408 Request timeout, 客户端请求超时</li>
<li>409 Confict, 请求的资源可能引起冲突</li>
</ul>
</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。<ul>
<li>500 internal sever error，表示服务器端在执⾏请求时发⽣了错误 ✨</li>
<li>501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务<br>器不⽀持的某个⽅法</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li>
<li>505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li>
</ul>
</li>
</ul>
<h2 id="Vue-部分"><a href="#Vue-部分" class="headerlink" title="Vue 部分"></a>Vue 部分</h2><h3 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h3><p>MVVM的全称是Model-View-View-Model</p>
<p>Model层：数据层</p>
<p>View层：视图层</p>
<p>View-Model层：业务逻辑层</p>
<ul>
<li>在Vue中，Model层与View不进行数据交互，而是通过View-Model进行同步</li>
<li>Model与View-Model之间的交互是双向的，</li>
<li>ViewModel通过双向数据绑定将Model和View之间联系起来</li>
</ul>
<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>Vue采用虚拟DOM代替对真实DOM的操作，最后通过某种机制完成对真实DOM的更新</p>
<p>虚拟DOM：是通过JS进行模拟的，把DOM的变化放在JS层来做，尽量减少对DOM的操作，对过diff算法，算出最小差异，然后修改真实DOM，</p>
<p>Vue中DOM操作流程</p>
<ul>
<li>在内存中构建DOM树</li>
<li>将内存中的虚拟DOM渲染成真实DOM</li>
<li>数据改变之后，将之前的虚拟DOM树结合新的数据生成新的DOM树</li>
<li>通过diff算法进行新老DOM树的对比，不必全部重绘</li>
<li>重新进行渲染</li>
</ul>
<h3 id="V-for-key值的作用"><a href="#V-for-key值的作用" class="headerlink" title="V-for key值的作用"></a>V-for key值的作用</h3><ul>
<li>和diff算法有关，有key值的话，只需插入到对应位置即可，不会改变元素的走向</li>
<li>为了避免一些出错：新增数据，如果没有设置key，选中的状态就会变成新增的那条</li>
</ul>
<h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>计算属性通过其他属性算出一个新的数据，然后把新的数据缓存下来，它调用的是缓存中的数据，极大提高了程序的性能，和methods不同，methods没有缓存的概念，不管数据是否发生变化，methods都会重新调用</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>一个对象，键是data对应的数据，值是对应的回调函数。当data发送变化时，就会产生一个回调，watch监听依赖是单个的，他每次监听只能监听一个变量的改变。</p>
<h3 id="Vue-双向绑定的实现原理"><a href="#Vue-双向绑定的实现原理" class="headerlink" title="Vue 双向绑定的实现原理"></a>Vue 双向绑定的实现原理</h3><p>Vue在创建vm的时候，会将数据配置到在实例之中，然后通过Object.defineProperty对数据进行操作，为数据动态添加getter和setter方法，当获取数据时调用getter方法，修改数据时调用setter方法，从而进一步调用vm中的watch方法，将更改后的数据渲染到视图中</p>
<h3 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick( )"></a>this.$nextTick( )</h3><p>就是DOM渲染完毕后再执行后面的回调函数，created()中使用的方法时，dom还没有渲染，如果此时在该钩子函数中进行dom赋值数据（或者其它dom操作）时无异于徒劳，所以，此时this.$nextTick()就会被大量使用，而与created()对应的是mounted()的钩子函数则是在dom完全渲染后才开始渲染数据，所以在mounted()中操作dom基本不会存在渲染问题。</p>
<h3 id="Vue中常用的声明周期"><a href="#Vue中常用的声明周期" class="headerlink" title="Vue中常用的声明周期"></a>Vue中常用的声明周期</h3><p>初始化阶段</p>
<blockquote>
<h4 id="beforecCreated"><a href="#beforecCreated" class="headerlink" title="beforecCreated"></a>beforecCreated</h4><p>不能获取数据，dom元素也没有渲染出来</p>
<h4 id="created"><a href="#created" class="headerlink" title="created"></a>created</h4><p>此钩子函数，数据已经挂载，在还没有渲染出DOM节点，可以做一个初始化相关的操作，ajax请求等</p>
<h4 id="beforeMounted"><a href="#beforeMounted" class="headerlink" title="beforeMounted"></a>beforeMounted</h4><p>dom节点马上就要渲染出来了，和created大致相同</p>
<h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>此时，dom节点已经被渲染出来，数据已经挂载，可以获取到真实dom</p>
</blockquote>
<p>运行中阶段</p>
<blockquote>
<h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h4><p>数据发生更改单dom还没有被重新渲染，千万不能在此阶段进行数据更改，不然会死循环</p>
<h4 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h4><p>这个钩子函数获取到的是更新后的数据，并可以获取到更改后渲染的真实dom</p>
</blockquote>
<p>销毁阶段</p>
<blockquote>
<h4 id="beforeDestory"><a href="#beforeDestory" class="headerlink" title="beforeDestory"></a>beforeDestory</h4><p>切换路由的时候，组件就要被销毁，发送在销毁前</p>
<h4 id="destoryed"><a href="#destoryed" class="headerlink" title="destoryed"></a>destoryed</h4><p>此时双向数据绑定，watcher已经被全部移除，但是还存在真实dom</p>
</blockquote>
<h3 id="vue中的组件通信"><a href="#vue中的组件通信" class="headerlink" title="vue中的组件通信"></a>vue中的组件通信</h3><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><p>父组件中</p>
<p><img src="https://img-blog.csdnimg.cn/20181218175420153.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/201812181754339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaWFuX3pob3U=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p>子组件中：</p>
<p><img src="https://img-blog.csdnimg.cn/20181218174742995.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p>Prop 是单向绑定的：当父组件的属性变化时，将传递给子组件，但是反过来不会。即子组件通过props接收传递过来的数据，实现单向数据流</p>
<h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4><p>父组件中：</p>
<p><img src="https://img-blog.csdnimg.cn/20181218175910857.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20181218183034315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaWFuX3pob3U=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p>子组件部分</p>
<p><img src="https://img-blog.csdnimg.cn/20181218174525607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaWFuX3pob3U=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20181218174544865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaWFuX3pob3U=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<p>父组件给子组件绑定一个自定义事件，当子组件触发这个程序的时候，相当于父组件的方法被执行，</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E5%8C%BA/">学习区</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">�������������³��ر������⣬������ <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 Э��</a> ��ת����ע��������</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/09/ajax%E8%AF%B7%E6%B1%82%E7%9A%845%E6%AD%A5/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Ajax请求的5步</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/09/%E6%AF%95%E8%AE%BE%E8%BF%9B%E5%BA%A6%E6%89%93%E5%8D%A11/">
                        <span class="hidden-mobile">毕设绩效管理系统进度打卡day1(持续更新)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
